/*
 * This file was generated by:
 * F:/P3D/1.9GIT/built_x64_buffered/bin/interrogate -D__inline -DCPPPARSER -DP3_INTERROGATE=1 -D__cplusplus -fnames -string -refcount -assert -Dvolatile= -DWIN32= -DWIN32_VC= -D_WINDOWS= -SF:/P3D/1.9GIT/built_x64_buffered/include/parser-inc -SF:/P3D/1.9GIT/built_x64_buffered/include/ -IF:/P3D/1.9GIT/built_x64_buffered/bin/include/ -oc Source/InterrogateModule.cxx -od Source/InterrogateModule.in -python-native -module RSCoreModules -library RSCoreModules -srcdir E:/Projects/Brainz stuff/RenderSystem/Core/Source TerrainMeshRenderer.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_RSCoreModules
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "TerrainMeshRenderer.h"
#include "boundingBox.h"
#include <cmath>
#include "datagram.h"
#include "dtool_config.h"
#include <fstream>
#include "geomEnums.h"
#include <iostream>
#include "lens.h"
#include "loader.h"
#include "nodePath.h"
#include "omniBoundingVolume.h"
#include "pandabase.h"
#include "pnmImage.h"
#include "texture.h"

#undef _POSIX_C_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif

//********************************************************************
//*** prototypes for .. Global
//********************************************************************
//********************************************************************
//*** prototypes for .. TerrainMeshRenderer
//********************************************************************
typedef TerrainMeshRenderer TerrainMeshRenderer_localtype;
Define_Module_Class(RSCoreModules, TerrainMeshRenderer, TerrainMeshRenderer_localtype, TerrainMeshRenderer);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TerrainMeshRenderer = &Dtool_TerrainMeshRenderer;
static void Dtool_PyModuleClassInit_TerrainMeshRenderer(PyObject *module);

//********************************************************************
//*** prototypes for .. External Objects
//********************************************************************
// LVecBase3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase3f;
inline static LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced) {
  nassertr(Dtool_Ptr_LVecBase3f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase3f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase3f *(*)(PyObject *, LVecBase3f &))Dtool_Ptr_LVecBase3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3f = &Dtool_LVecBase3f;
extern LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced);
#endif
// NodePath
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_NodePath;
#else
extern struct Dtool_PyTypedObject Dtool_NodePath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePath = &Dtool_NodePath;
#endif
// Lens
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Lens;
#else
extern struct Dtool_PyTypedObject Dtool_Lens;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Lens = &Dtool_Lens;
#endif

//********************************************************************
//*** Functions for .. Global
//********************************************************************
//********************************************************************
//*** Functions for .. TerrainMeshRenderer
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void TerrainMeshRenderer::create(void)
 *******************************************************************/
static PyObject *Dtool_TerrainMeshRenderer_create_4(PyObject *self, PyObject *) {
  TerrainMeshRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TerrainMeshRenderer, (void **)&local_this, "TerrainMeshRenderer.create")) {
    return NULL;
  }
  // 1-void TerrainMeshRenderer::create(void)
  local_this->create();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TerrainMeshRenderer_create_4_comment =
  "C++ Interface:\n"
  "create(const TerrainMeshRenderer self)\n";
#else
static const char *Dtool_TerrainMeshRenderer_create_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TerrainMeshRenderer::update(void)
 *******************************************************************/
static PyObject *Dtool_TerrainMeshRenderer_update_5(PyObject *self, PyObject *) {
  TerrainMeshRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TerrainMeshRenderer, (void **)&local_this, "TerrainMeshRenderer.update")) {
    return NULL;
  }
  // 1-void TerrainMeshRenderer::update(void)
  local_this->update();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TerrainMeshRenderer_update_5_comment =
  "C++ Interface:\n"
  "update(const TerrainMeshRenderer self)\n";
#else
static const char *Dtool_TerrainMeshRenderer_update_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TerrainMeshRenderer::set_heightfield_size(int size)
 *******************************************************************/
static PyObject *Dtool_TerrainMeshRenderer_set_heightfield_size_6(PyObject *self, PyObject *arg) {
  TerrainMeshRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TerrainMeshRenderer, (void **)&local_this, "TerrainMeshRenderer.set_heightfield_size")) {
    return NULL;
  }
  // 1-void TerrainMeshRenderer::set_heightfield_size(int size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    local_this->set_heightfield_size((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_heightfield_size(const TerrainMeshRenderer self, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TerrainMeshRenderer_set_heightfield_size_6_comment =
  "C++ Interface:\n"
  "set_heightfield_size(const TerrainMeshRenderer self, int size)\n";
#else
static const char *Dtool_TerrainMeshRenderer_set_heightfield_size_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TerrainMeshRenderer::set_focus(NodePath *cam, Lens *lens)
 *******************************************************************/
static PyObject *Dtool_TerrainMeshRenderer_set_focus_7(PyObject *self, PyObject *args, PyObject *kwds) {
  TerrainMeshRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TerrainMeshRenderer, (void **)&local_this, "TerrainMeshRenderer.set_focus")) {
    return NULL;
  }
  // 1-void TerrainMeshRenderer::set_focus(NodePath *cam, Lens *lens)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"cam", "lens", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_focus", (char **)keyword_list, &param1, &param2)) {
    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "TerrainMeshRenderer.set_focus", false, true);
    Lens *param2_this = (Lens *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Lens, 2, "TerrainMeshRenderer.set_focus", false, true);
    if (param1_this != NULL && param2_this != NULL) {
      local_this->set_focus(param1_this, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_focus(const TerrainMeshRenderer self, NodePath cam, Lens lens)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TerrainMeshRenderer_set_focus_7_comment =
  "C++ Interface:\n"
  "set_focus(const TerrainMeshRenderer self, NodePath cam, Lens lens)\n";
#else
static const char *Dtool_TerrainMeshRenderer_set_focus_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TerrainMeshRenderer::load_chunk_mesh(string const &filename)
 *******************************************************************/
static PyObject *Dtool_TerrainMeshRenderer_load_chunk_mesh_8(PyObject *self, PyObject *arg) {
  TerrainMeshRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TerrainMeshRenderer, (void **)&local_this, "TerrainMeshRenderer.load_chunk_mesh")) {
    return NULL;
  }
  // 1-void TerrainMeshRenderer::load_chunk_mesh(string const &filename)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    local_this->load_chunk_mesh(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_chunk_mesh(const TerrainMeshRenderer self, str filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TerrainMeshRenderer_load_chunk_mesh_8_comment =
  "C++ Interface:\n"
  "load_chunk_mesh(const TerrainMeshRenderer self, str filename)\n";
#else
static const char *Dtool_TerrainMeshRenderer_load_chunk_mesh_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TerrainMeshRenderer::load_bounds(string const &filename)
 *******************************************************************/
static PyObject *Dtool_TerrainMeshRenderer_load_bounds_9(PyObject *self, PyObject *arg) {
  TerrainMeshRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TerrainMeshRenderer, (void **)&local_this, "TerrainMeshRenderer.load_bounds")) {
    return NULL;
  }
  // 1-void TerrainMeshRenderer::load_bounds(string const &filename)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    local_this->load_bounds(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_bounds(const TerrainMeshRenderer self, str filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TerrainMeshRenderer_load_bounds_9_comment =
  "C++ Interface:\n"
  "load_bounds(const TerrainMeshRenderer self, str filename)\n";
#else
static const char *Dtool_TerrainMeshRenderer_load_bounds_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TerrainMeshRenderer::set_scale(LVecBase3 scale)
 * void TerrainMeshRenderer::set_scale(float sx, float sy, float height)
 *******************************************************************/
static PyObject *Dtool_TerrainMeshRenderer_set_scale_10(PyObject *self, PyObject *args, PyObject *kwds) {
  TerrainMeshRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TerrainMeshRenderer, (void **)&local_this, "TerrainMeshRenderer.set_scale")) {
    return NULL;
  }
  int parameter_count = PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "scale");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'scale' (pos 1) not found");
      }
      // 1-void TerrainMeshRenderer::set_scale(LVecBase3 scale)
      LVecBase3f arg_local;
      LVecBase3 *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "TerrainMeshRenderer.set_scale", "LVecBase3f");
      }
      local_this->set_scale(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-void TerrainMeshRenderer::set_scale(float sx, float sy, float height)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"sx", "sy", "height", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_scale", (char **)keyword_list, &param1, &param2, &param3)) {
        local_this->set_scale((float)param1, (float)param2, (float)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_scale() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scale(const TerrainMeshRenderer self, LVecBase3f scale)\n"
      "set_scale(const TerrainMeshRenderer self, float sx, float sy, float height)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TerrainMeshRenderer_set_scale_10_comment =
  "C++ Interface:\n"
  "set_scale(const TerrainMeshRenderer self, LVecBase3f scale)\n"
  "set_scale(const TerrainMeshRenderer self, float sx, float sy, float height)\n";
#else
static const char *Dtool_TerrainMeshRenderer_set_scale_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TerrainMeshRenderer::set_pos(LVecBase3 pos)
 * void TerrainMeshRenderer::set_pos(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_TerrainMeshRenderer_set_pos_11(PyObject *self, PyObject *args, PyObject *kwds) {
  TerrainMeshRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TerrainMeshRenderer, (void **)&local_this, "TerrainMeshRenderer.set_pos")) {
    return NULL;
  }
  int parameter_count = PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "pos");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'pos' (pos 1) not found");
      }
      // 1-void TerrainMeshRenderer::set_pos(LVecBase3 pos)
      LVecBase3f arg_local;
      LVecBase3 *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "TerrainMeshRenderer.set_pos", "LVecBase3f");
      }
      local_this->set_pos(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-void TerrainMeshRenderer::set_pos(float x, float y, float z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_pos", (char **)keyword_list, &param1, &param2, &param3)) {
        local_this->set_pos((float)param1, (float)param2, (float)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_pos() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pos(const TerrainMeshRenderer self, LVecBase3f pos)\n"
      "set_pos(const TerrainMeshRenderer self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TerrainMeshRenderer_set_pos_11_comment =
  "C++ Interface:\n"
  "set_pos(const TerrainMeshRenderer self, LVecBase3f pos)\n"
  "set_pos(const TerrainMeshRenderer self, float x, float y, float z)\n";
#else
static const char *Dtool_TerrainMeshRenderer_set_pos_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TerrainMeshRenderer::set_target_triangle_width(float width)
 *******************************************************************/
static PyObject *Dtool_TerrainMeshRenderer_set_target_triangle_width_12(PyObject *self, PyObject *arg) {
  TerrainMeshRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TerrainMeshRenderer, (void **)&local_this, "TerrainMeshRenderer.set_target_triangle_width")) {
    return NULL;
  }
  // 1-void TerrainMeshRenderer::set_target_triangle_width(float width)
  if (PyNumber_Check(arg)) {
    local_this->set_target_triangle_width((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_target_triangle_width(const TerrainMeshRenderer self, float width)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TerrainMeshRenderer_set_target_triangle_width_12_comment =
  "C++ Interface:\n"
  "set_target_triangle_width(const TerrainMeshRenderer self, float width)\n";
#else
static const char *Dtool_TerrainMeshRenderer_set_target_triangle_width_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TerrainMeshRenderer::set_culling_enabled(bool enabled)
 *******************************************************************/
static PyObject *Dtool_TerrainMeshRenderer_set_culling_enabled_13(PyObject *self, PyObject *arg) {
  TerrainMeshRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TerrainMeshRenderer, (void **)&local_this, "TerrainMeshRenderer.set_culling_enabled")) {
    return NULL;
  }
  // 1-void TerrainMeshRenderer::set_culling_enabled(bool enabled)
  local_this->set_culling_enabled((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_culling_enabled(const TerrainMeshRenderer self, bool enabled)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TerrainMeshRenderer_set_culling_enabled_13_comment =
  "C++ Interface:\n"
  "set_culling_enabled(const TerrainMeshRenderer self, bool enabled)\n";
#else
static const char *Dtool_TerrainMeshRenderer_set_culling_enabled_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NodePath TerrainMeshRenderer::get_node(void)
 *******************************************************************/
static PyObject *Dtool_TerrainMeshRenderer_get_node_14(PyObject *self, PyObject *) {
  TerrainMeshRenderer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TerrainMeshRenderer, (void **)&local_this, "TerrainMeshRenderer.get_node")) {
    return NULL;
  }
  // 1-NodePath TerrainMeshRenderer::get_node(void)
  NodePath *return_value = new NodePath(local_this->get_node());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TerrainMeshRenderer_get_node_14_comment =
  "C++ Interface:\n"
  "get_node(const TerrainMeshRenderer self)\n";
#else
static const char *Dtool_TerrainMeshRenderer_get_node_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static void TerrainMeshRenderer::generate_bounds(string const &filename, string const &dest, int chunk_size = 32)
 *******************************************************************/
static PyObject *Dtool_TerrainMeshRenderer_generate_bounds_15(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static void TerrainMeshRenderer::generate_bounds(string const &filename, string const &dest, int chunk_size = 32)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  int param2 = 32;
  static const char *keyword_list[] = {"filename", "dest", "chunk_size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#|i:generate_bounds", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2)) {
    TerrainMeshRenderer::generate_bounds(std::string(param0_str, param0_len), std::string(param1_str, param1_len), (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "generate_bounds(str filename, str dest, int chunk_size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TerrainMeshRenderer_generate_bounds_15_comment =
  "C++ Interface:\n"
  "generate_bounds(str filename, str dest, int chunk_size)\n";
#else
static const char *Dtool_TerrainMeshRenderer_generate_bounds_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TerrainMeshRenderer::TerrainMeshRenderer(void)
 *******************************************************************/
static int Dtool_Init_TerrainMeshRenderer(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "TerrainMeshRenderer() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-TerrainMeshRenderer::TerrainMeshRenderer(void)
  TerrainMeshRenderer *return_value = new TerrainMeshRenderer();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TerrainMeshRenderer, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TerrainMeshRenderer()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_TerrainMeshRenderer(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_TerrainMeshRenderer) {
    printf("TerrainMeshRenderer ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  TerrainMeshRenderer *local_this = (TerrainMeshRenderer *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_TerrainMeshRenderer) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_TerrainMeshRenderer(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_TerrainMeshRenderer) {
    return from_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Py Init Code For .. TerrainMeshRenderer | TerrainMeshRenderer
//********************************************************************
static PyMethodDef Dtool_Methods_TerrainMeshRenderer[] = {
  {"create", &Dtool_TerrainMeshRenderer_create_4, METH_NOARGS, (const char *)Dtool_TerrainMeshRenderer_create_4_comment},
  {"update", &Dtool_TerrainMeshRenderer_update_5, METH_NOARGS, (const char *)Dtool_TerrainMeshRenderer_update_5_comment},
  {"set_heightfield_size", &Dtool_TerrainMeshRenderer_set_heightfield_size_6, METH_O, (const char *)Dtool_TerrainMeshRenderer_set_heightfield_size_6_comment},
  {"setHeightfieldSize", &Dtool_TerrainMeshRenderer_set_heightfield_size_6, METH_O, (const char *)Dtool_TerrainMeshRenderer_set_heightfield_size_6_comment},
  {"set_focus", (PyCFunction) &Dtool_TerrainMeshRenderer_set_focus_7, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TerrainMeshRenderer_set_focus_7_comment},
  {"setFocus", (PyCFunction) &Dtool_TerrainMeshRenderer_set_focus_7, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TerrainMeshRenderer_set_focus_7_comment},
  {"load_chunk_mesh", &Dtool_TerrainMeshRenderer_load_chunk_mesh_8, METH_O, (const char *)Dtool_TerrainMeshRenderer_load_chunk_mesh_8_comment},
  {"loadChunkMesh", &Dtool_TerrainMeshRenderer_load_chunk_mesh_8, METH_O, (const char *)Dtool_TerrainMeshRenderer_load_chunk_mesh_8_comment},
  {"load_bounds", &Dtool_TerrainMeshRenderer_load_bounds_9, METH_O, (const char *)Dtool_TerrainMeshRenderer_load_bounds_9_comment},
  {"loadBounds", &Dtool_TerrainMeshRenderer_load_bounds_9, METH_O, (const char *)Dtool_TerrainMeshRenderer_load_bounds_9_comment},
  {"set_scale", (PyCFunction) &Dtool_TerrainMeshRenderer_set_scale_10, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TerrainMeshRenderer_set_scale_10_comment},
  {"setScale", (PyCFunction) &Dtool_TerrainMeshRenderer_set_scale_10, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TerrainMeshRenderer_set_scale_10_comment},
  {"set_pos", (PyCFunction) &Dtool_TerrainMeshRenderer_set_pos_11, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TerrainMeshRenderer_set_pos_11_comment},
  {"setPos", (PyCFunction) &Dtool_TerrainMeshRenderer_set_pos_11, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TerrainMeshRenderer_set_pos_11_comment},
  {"set_target_triangle_width", &Dtool_TerrainMeshRenderer_set_target_triangle_width_12, METH_O, (const char *)Dtool_TerrainMeshRenderer_set_target_triangle_width_12_comment},
  {"setTargetTriangleWidth", &Dtool_TerrainMeshRenderer_set_target_triangle_width_12, METH_O, (const char *)Dtool_TerrainMeshRenderer_set_target_triangle_width_12_comment},
  {"set_culling_enabled", &Dtool_TerrainMeshRenderer_set_culling_enabled_13, METH_O, (const char *)Dtool_TerrainMeshRenderer_set_culling_enabled_13_comment},
  {"setCullingEnabled", &Dtool_TerrainMeshRenderer_set_culling_enabled_13, METH_O, (const char *)Dtool_TerrainMeshRenderer_set_culling_enabled_13_comment},
  {"get_node", &Dtool_TerrainMeshRenderer_get_node_14, METH_NOARGS, (const char *)Dtool_TerrainMeshRenderer_get_node_14_comment},
  {"getNode", &Dtool_TerrainMeshRenderer_get_node_14, METH_NOARGS, (const char *)Dtool_TerrainMeshRenderer_get_node_14_comment},
  {"generate_bounds", (PyCFunction) &Dtool_TerrainMeshRenderer_generate_bounds_15, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TerrainMeshRenderer_generate_bounds_15_comment},
  {"generateBounds", (PyCFunction) &Dtool_TerrainMeshRenderer_generate_bounds_15, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TerrainMeshRenderer_generate_bounds_15_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_TerrainMeshRenderer = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
};

struct Dtool_PyTypedObject Dtool_TerrainMeshRenderer = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "RSCoreModules.TerrainMeshRenderer",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_TerrainMeshRenderer,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_TerrainMeshRenderer,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_TerrainMeshRenderer,
    standard_type_members,
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_TerrainMeshRenderer,
    PyType_GenericAlloc,
    Dtool_new_TerrainMeshRenderer,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TerrainMeshRenderer,
  Dtool_UpcastInterface_TerrainMeshRenderer,
  Dtool_DowncastInterface_TerrainMeshRenderer,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_TerrainMeshRenderer(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_DTOOL_SUPER_BASE != NULL);
    Dtool_Ptr_DTOOL_SUPER_BASE->_Dtool_ModuleClassInit(NULL);
    Dtool_TerrainMeshRenderer._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE);
    PyObject *dict = PyDict_New();
    Dtool_TerrainMeshRenderer._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TerrainMeshRenderer) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TerrainMeshRenderer)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TerrainMeshRenderer);
  }
}


//********************************************************************
//*** Module Object Linker ..
//********************************************************************
void Dtool_RSCoreModules_RegisterTypes() {
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("TerrainMeshRenderer", Dtool_TerrainMeshRenderer);
#endif
}

void Dtool_RSCoreModules_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_LVecBase3f = LookupRuntimeTypedClass(LVecBase3f::get_class_type());
  Dtool_Ptr_NodePath = LookupRuntimeTypedClass(NodePath::get_class_type());
  Dtool_Ptr_Lens = LookupRuntimeTypedClass(Lens::get_class_type());
#endif
}

void Dtool_RSCoreModules_BuildInstants(PyObject *module) {
  (void) module;
  // Module init upcall for TerrainMeshRenderer
  // TerrainMeshRenderer
  Dtool_PyModuleClassInit_TerrainMeshRenderer(module);
  PyModule_AddObject(module, "TerrainMeshRenderer", (PyObject *)&Dtool_TerrainMeshRenderer);
//********************************************************************
//*** Module Init Upcall ..  Externally Defined Class
//********************************************************************
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef RSCoreModules_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1438597043,  /* file_identifier */
  "RSCoreModules",  /* library_name */
  "iNUn",  /* library_hash_name */
  "RSCoreModules",  /* module_name */
  "InterrogateModule.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  46  /* next_index */
};

Configure(_in_configure_RSCoreModules);
ConfigureFn(_in_configure_RSCoreModules) {
  interrogate_request_module(&_in_module_def);
}

